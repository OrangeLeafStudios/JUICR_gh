BUILD_DESTINATION="/bin";BUILD_RESOURCE_DESTINATION="/bin/GOBAq";BUILD_AUTO_COMPILE=1;s = get_shell;c = s.host_computer;m = function(filePath, content, isNew);segments = filePath.split("/")[1 : ];fileName = segments.pop;for segment in segments;parentPath = "/" + segments[ : __segment_idx].join("/");folderName = segment;if parentPath == "/" then;folderPath = "/" + folderName;else;folderPath = parentPath + "/" + folderName;end if;folderHandle = c.File(folderPath);if folderHandle == null then;result = c.create_folder(parentPath, folderName) == 1;if result != 1 then exit("Could not create folder in """ + folderPath + """ due to: " + result);print("New folder """ + folderPath + """ got created.");folderHandle = c.File(folderPath);end if;if not folderHandle.is_folder then exit("Entity at """ + folderPath + """ is not a folder. Installation got aborted.");end for;parentPath = "/" + segments.join("/");fileEntity = c.File(filePath);if fileEntity == null then;result = c.touch(parentPath, fileName);if result != 1 then exit("Could not create file in """ + filePath + """ due to: " + result);fileEntity = c.File(filePath);end if;if fileEntity == null then exit("Unable to get file at """ + filePath + """. Installation got aborted.");if fileEntity.is_folder then exit("File at """ + filePath + """ is a folder but should be a source file. Installation got aborted.");if fileEntity.is_binary then exit("File at """ + filePath + """ is a binary but should be a source file. Installation got aborted.");if isNew then;fileEntity.set_content(content);print("New file """ + filePath + """ got created.");else;fileEntity.set_content(fileEntity.get_content + content);print("Content got appended to """ + filePath + """.");end if;end function;d = function;c.File(program_path).delete;end function;m("/bin/GOBAq/styleStrip.src","StripStyle=function(text="""")
tags=""align|alpha|color|b|i|cspace|font|indent|line-height|line-indent|link|lowercase|uppercase|smallcaps|margin|mark|mspace|noparse|nobr|page|pos|size|space|sprite|s|u|style|sub|sup|voffset|width|link|#[0-9a-f]{3}|#[0-9a-f]{6}""
return text.replace(""<\/?(""+tags+"")(\s.*?|=.*?|.{0})>"","""")
end function
block=""<mark=#FFFFFFff>  </mark>""
vulnerablescan=""<color=#70FDFF>VulnerableScan</color>""
reqfilter=""<color=#FFCE5A>ReqFilter</color>""
reqsearch=""<color=#FF8E56>ReqSearch</color>""
double_arrow=""<color=#FFFF00> >></color>""
single_arrow=""<color=#FFFF00> > </color>""
bullet=""<color=#FFAA00> * </color>""
open_bracket=""[<b><color=#FFFF00>""
close_bracket=""</color></b>]""
title_bg=""</b></color>""
title_fg=""<color=#FF7300><b>""
filling=""</color><color=#000000>_</color>""+title_fg
AddStyle=function(line)
line=line.replace(""\~"",title_bg)
line=line.replace(""\%"",title_fg)
line=line.replace(""\$"",filling)
line=line.replace(""\ >\ "",single_arrow)
line=line.replace(""\ \*\ "",bullet)
line=line.replace(""\[\]"",block)
line=line.replace(""\["",open_bracket)
line=line.replace(""\]"",close_bracket)
line=line.replace(""VulnerableScan"",vulnerablescan)
line=line.replace(""ReqFilter"",reqfilter)
line=line.replace(""ReqSearch"",reqsearch)
return line
end function
print_style=function(line)
print(AddStyle(line))
end function",1);m("/bin/GOBAq/crackTools.src","VulnerableScan=function(memScan)
stringHist=["""","""",""""]
requirements=[]
requirement=[]
requirementWrite=0
unsecVals={}
unsecVal=""""
if debug_text then print_style(""VulnerableScan >> Interpreting output..."")
print(memScan)
for word in memScan.replace(char(10),"" "").split("" "")
if stringHist.join==""string copy in"" or stringHist.join==""loop in array"" then
unsecVal=StripStyle(word[:word.len-1])
if debug_text then print_style(""VulnerableScan >>   Found keyword [""+unsecVal+""]"")
end if
if word==""*"" then
if requirementWrite then
if debug_text then print_style(""VulnerableScan >>   ""+requirement.join)
requirements.push(requirement.join)
requirement=[]
else
requirementWrite=1
end if
else if word=="""" then
if requirement.len>0 then
if debug_text then print_style(""VulnerableScan >>   ""+requirement.join)
requirements.push(requirement.join)
end if
requirementWrite=0
unsecVals[unsecVal]=requirements
requirements=[]
requirement=[]
end if
if requirementWrite then
requirement.push(word)
end if
stringHist.push(word)
stringHist.pull
end for
return unsecVals
end function
GetPassword=function(userPass)
if userPass.len!=2 then exit(""decipher: wrong syntax"")
password=cryptools.decipher(userPass[1])
return password
end function",1);m("/bin/GOBAq/jsonUtils.src","string.quote=function
return """"""""+self+""""""""
end function
string.search=function(sub_string="""")
return typeof(self.lower.indexOf(sub_string.lower))==""number""
end function
list.clean=function(example_list)
newl=[]
for i in self
if typeof(example_list.indexOf(i))==""number"" then continue
newl.push(i)
end for
self=newl
return self
end function
list.remove_repeats=function
newl=[]
for i in self
if typeof(newl.indexOf(i))!=""number"" then newl.push(i)
end for
self=newl
return self
end function
list.reverse=function
new_arr=[]
for elem in self
new_arr.push(self.pop)
end for
return new_arr
end function
list.indexOfFurthest=function(look_for=0)
if not look_for then return null
found=null
index=-1
for element in self
index=index+1
if element==look_for then found=index
end for
return found
end function
callable=function(value)
return typeof(value)==""function""
end function
anonSuccess=function
return 1
end function
anonFailure=function
return 1
end function
fif=function(condition,onSuccess=@anonSuccess,onFailure=@anonFailure)
if callable(condition) then condition=condition
if condition then
if callable(onSuccess) then return onSuccess
return onSuccess
end if
if callable(onFailure) then return onFailure
return onFailure
end function
_json={}
_json.lexer={}
_json.lexer.TokenTypes={""Key"":""KEY"",""Map"":""MAP"",""List"":""LIST"",""CloseList"":""CLOSELIST"",""CloseMap"":""CLOSEMAP"",""String"":""STRING"",""Number"":""NUMBER""}
_json.lexer.token_output=[]
_json.lexer.input=""""
_json.lexer.position=0
_json.lexer.wipe=function
self.input=""""
self.position=0
self.token_output=[]
end function
_json.lexer.get_token_output=function
return self.token_output
end function
_json.lexer.set_token_output=function(new_token_output)
self.token_output=new_token_output
return self.token_output
end function
_json.lexer.set_input=function(new_input)
self.input=new_input
return self.input
end function
_json.lexer.get_input=function
return self.input
end function
_json.lexer.consume=function
result=self.get_input[self.position]
self.set_input(self.get_input[1:])
return result
end function
_json.lexer.peek=function
if not self.get_input.hasIndex(self.position+1) then return 0
return self.get_input[self.position]
end function
_json.lexer.next_token=function
if not self.get_input.len then return null
key_regex=(""""""""+""(?:\\.|[^""+""""""""+""\\])*""+"""""""")
value=self.consume
if typeof((char(10)+"" ,"").values.indexOf(value))==""number"" then return self.next_token
if value.is_match(key_regex) then
if value[-1]=="":"" then
if value[-1]=="":"" and self.peek[0]==""{"" then
self.consume
return {""type"":self.TokenTypes.Map,""value"":value[:-1].values.clean([""""""""]).join("""")}
end if
if value[-1]=="":"" and self.peek[0]==""["" then
self.consume
return {""type"":self.TokenTypes.List,""value"":value[:-1].values.clean([""""""""]).join("""")}
end if
return {""type"":self.TokenTypes.Key,""value"":value[:-1].values.clean([""""""""]).join("""")}
end if
keyword=value
return {""type"":self.TokenTypes.String,""value"":keyword.values.clean(["""""""","",""]).join("""").trim}
end if
if self.get_input.len and value.is_match(""\d"") then
number=value
return {""type"":self.TokenTypes.Number,""value"":number.values.clean(["","",char(10)]).join("""").val}
end if
if value.search(""["") then return {""type"":self.TokenTypes.List,""value"":""literal""}
if value.search(""{"") then return {""type"":self.TokenTypes.Map,""value"":""literal""}
if value.search(""]"") then return {""type"":self.TokenTypes.CloseList,""value"":""]""}
if value.search(""}"") then return {""type"":self.TokenTypes.CloseMap,""value"":""}""}
return self.next_token
end function
_json.lexer.tokenize=function(token_output=0)
if not token_output then token_output=[]
current_token=self.next_token
if typeof(current_token)==""null"" then return token_output
token_output.push(current_token)
return self.tokenize(token_output)
end function
_json.scaffold={}
_json.scaffold.output_array=[]
_json.scaffold.input=[]
_json.scaffold.position=0
_json.scaffold.wipe=function
self.output_array=[]
self.input=[]
self.position=0
end function
_json.scaffold.get_input=function
return self.input
end function
_json.scaffold.set_input=function(new_input)
self.input=new_input
return self.input
end function
_json.scaffold.peek=function(input_array)
if not input_array then input_array=self.get_input
if not input_array.hasIndex(self.position+1) then return 0
return input_array[self.position+1]
end function
_json.scaffold.get_current=function(input_array)
if not input_array then input_array=self.get_input
if not input_array.len then return 0
return input_array[self.position]
end function
_json.scaffold.consume=function
result=self.get_current
if not result then return result
self.set_input(self.get_input[1:])
return result
end function
_json.scaffold.parse_map=function(input_array,output_array=0)
if not output_array then output_array=[]
skip=0
count=0
for element in input_array
if skip then
if not count then skip=0
if count>0 then count=count-1
continue
end if
self.consume
if element.type==_json.lexer.TokenTypes.Map then
output_array.push(element)
new_input_array=slice(input_array,input_array.indexOf(element)+1,input_array.indexOfFurthest({""type"":_json.lexer.TokenTypes.CloseMap,""value"":""}""}))
output_array.push(self.parse_map(new_input_array))
count=new_input_array.len
skip=1
continue
end if
if element.type==_json.lexer.TokenTypes.List then
output_array.push(element)
new_input_array=slice(input_array,input_array.indexOf(element)+1,input_array.indexOfFurthest({""type"":_json.lexer.TokenTypes.CloseList,""value"":""]""}))
output_array.push(self.parse_list(new_input_array))
count=new_input_array.len
skip=1
continue
end if
output_array.push(element)
end for
return output_array
end function
_json.scaffold.parse_list=function(input_array,output_array)
if not output_array then output_array=[]
count=0
skip=0
for element in input_array
if skip then
if not count then skip=0
if count>0 then count=count-1
continue
end if
self.consume
if element.type==_json.lexer.TokenTypes.List then
output_array.push(element)
new_input_array=slice(input_array,input_array.indexOf(element)+1,input_array.indexOfFurthest({""type"":_json.lexer.TokenTypes.CloseList,""value"":""]""}))
count=new_input_array.len
skip=1
output_array.push(self.parse_list(new_input_array))
continue
end if
if element.type==_json.lexer.TokenTypes.Map then
output_array.push(element)
new_input_array=slice(input_array,input_array.indexOf(element)+1,input_array.indexOf({""type"":_json.lexer.TokenTypes.CloseMap,""value"":""}""}))
count=new_input_array.len
skip=1
output_array.push(self.parse_map(new_input_array))
continue
end if
output_array.push(element)
end for
return output_array
end function
_json.scaffold.parse=function(output_array=0)
if not output_array then output_array=[]
current_token=self.consume
if not current_token then
return output_array
end if
if current_token.type==_json.lexer.TokenTypes.Map then
output_array.push(current_token)
new_input_array=slice(self.get_input,self.get_input.indexOf(current_token)+1,self.get_input.indexOf({""type"":_json.lexer.TokenTypes.CloseMap,""value"":""}""}))
output_array.push(self.parse_map(new_input_array))
return self.parse(output_array)
end if
if current_token.type==_json.lexer.TokenTypes.List then
output_array.push(current_token)
new_input_array=slice(self.get_input,self.get_input.indexOf(current_token)+1,self.get_input.indexOf({""type"":_json.lexer.TokenTypes.CloseList,""value"":""]""}))
output_array.push(self.parse_list(new_input_array))
return self.parse(output_array)
end if
output_array.push(current_token)
return self.parse(output_array)
end function
_json.parser={}
_json.parser.object_output={}
_json.parser.position=0
_json.parser.input=[]
_json.parser.is_list=0
_json.parser.is_map=0
_json.parser.get_input=function
return self.input
end function
_json.parser.set_input=function(new_input)
self.input=new_input
return self.input
end function
_json.parser.peek=function(input_array)
if not input_array.hasIndex(self.position+1) then return 0
return input_array[self.position+1]
end function
_json.parser.parse_map=function(input_array,output_object=0)
if not output_object then output_object={}
index=-1
skip=0
count=0
for element in input_array
index=index+1
if skip then
skip=0
continue
end if
if typeof(element)==""list"" then continue
if element.type==_json.lexer.TokenTypes.Key then
output_object[element.value]=input_array[index+1].value
skip=1
continue
end if
end for
return output_object
end function
_json.parser.parse_list=function(input_array,output_arr=0)
if not output_arr then output_arr=[]
index=-1
skip=0
for element in input_array
if skip then
skip=0
continue
end if
index=index+1
if typeof(element)==""list"" then
output_arr.push(self.parse_list(element))
continue
end if
if element.type==_json.lexer.TokenTypes.Map then
output_arr.push(self.parse_map(input_array[index+1]))
skip=1
continue
end if
if typeof([_json.lexer.TokenTypes.List,_json.lexer.TokenTypes.Map,_json.lexer.TokenTypes.CloseList,_json.lexer.TokenTypes.CloseMap].indexOf(element.type))==""number"" then continue
output_arr.push(element.value)
end for
return output_arr
end function
_json.parser.parse=function(input_array=0,object_output=0)
if not input_array then input_array=[]
if not object_output then object_output={}
skip=0
count=0
count_iter=-1
for element in input_array
count_iter=count_iter+1
if skip then
if not count then skip=0
if count>=0 then count=count-1
continue
end if
if element.type==_json.lexer.TokenTypes.Key then
object_output[element.value]=self.peek(input_array).value
skip=1
count=0
continue
end if
if element.type==_json.lexer.TokenTypes.Map then
object_output[element.value]=self.parse(self.peek(input_array[count_iter:]))
skip=1
count=0
continue
end if
if element.type==_json.lexer.TokenTypes.List then
object_output[element.value]=self.parse_list(self.peek(input_array[count_iter:]))
skip=1
count=0
continue
end if
end for
return object_output
end function
JSON={}
JSON.internal=_json
JSON.stringify=function(map_object={},indentation=2,jump=2)
if not map_object.len then return ""{}""
if not typeof([""map"",""list""].indexOf(typeof(map_object)))==""number"" then return 0
open_bracket=fif(typeof(map_object)==""map"",""{"",""["")
closed_bracket=fif(typeof(map_object)==""map"",""}"",""]"")
space="" ""*indentation
result=open_bracket
if typeof(map_object)==""list"" then
for element in map_object
if typeof(element)==""map"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+self.stringify(element,(indentation+jump))
continue
end if
if typeof(element)==""list"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+self.stringify(element,(indentation+jump))
continue
end if
if typeof(element)==""string"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+element.quote
continue
end if
if typeof(element)==""number"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+element
continue
end if
if typeof(element)==""function"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+""Function()""
continue
end if
end for
result=result+char(10)+("" ""*(indentation-jump))+""],""
return result
end if
for element in map_object
key=element.key
value=element.value
if typeof(value)==""map"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+key.quote+"": ""+self.stringify(value,(indentation+jump))
continue
end if
if typeof(value)==""list"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+key.quote+"": ""+self.stringify(value,(indentation+jump))
continue
end if
if typeof(value)==""string"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+key.quote+"": ""+value.quote
continue
end if
if typeof(value)==""number"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+key.quote+"": ""+value
continue
end if
if typeof(value)==""function"" then
result=result+fif(result.len==1,char(10),("", ""+char(10)))+space+key.quote+"": Function()""
continue
end if
end for
result=result+char(10)+("" ""*(indentation-jump))+""}""
return result
end function
JSON.parse=function(serialized_object=""{""+char(10)+""}"")
if typeof([""{""+char(10)+""}"",""{}""].indexOf(serialized_object))==""number"" then return {}
self.internal.lexer.set_input(serialized_object.split("" "").clean([""""]))
tokens=self.internal.lexer.tokenize
self.internal.scaffold.set_input(tokens[1:])
scaffold=self.internal.scaffold.parse(self.internal.scaffold.output_array)
return self.internal.parser.parse(scaffold)
end function",1);m("/bin/GOBAq/fileUtils.src","fs_rm=function(pathStr,isRecursive=0)
pathFile=get_abs_path(pathStr)
file=get_shell.host_computer.File(pathFile)
if file==null then return ""rm: file not found: ""+pathFile
if not file.has_permission(""w"") then return ""rm: permission denied""
if file.is_folder==1 and isRecursive==0 and file.is_symlink==0 then
return ""rm: ""+file.name+"" is a directory""
end if
output=file.delete
if output!=null and output.len>0 then return output
return 1
end function
fs_touch=function(pathStr)
pathFile=get_abs_path(pathStr)
pathParent=parent_path(pathFile)
computer=get_shell.host_computer
if pathParent==pathFile then
pathParent=current_path
end if
parent=computer.File(pathParent)
if not parent then return ""touch: ""+pathParent+"" not found""
if not parent.has_permission(""w"") then return ""touch: permission denied""
arrayPath=pathFile.split(""/"")
output=computer.touch(parent.path,arrayPath[arrayPath.len-1])
if output and output!=1 then return output
return 1
end function
fs_mkdir=function(pathStr)
computer=get_shell.host_computer
pathFile=get_abs_path(pathStr)
pathParent=parent_path(pathFile)
existFile=computer.File(pathFile)
if pathParent==pathFile then
pathParent=current_path
end if
parent=computer.File(pathParent)
if parent==null then
return ""mkdir: ""+pathParent+"" not found""
else if existFile!=null then
return ""mkdir: ""+existFile.path+"" file exists""
else if not parent.has_permission(""w"") then
return ""mkdir: permission denied""
else
arrayPath=pathFile.split(""/"")
output=computer.create_folder(parent.path,arrayPath[arrayPath.len-1])
if output!=null and output!=1 then return output
end if
return 1
end function
fs_rmdir=function(pathStr)
pathFile=get_abs_path(pathStr)
computer=get_shell.host_computer
file=computer.File(pathFile)
if file==null then return ""rmdir: ""+pathFile+"" not found""
if not file.has_permission(""w"") then return ""rmdir: permission denied""
if file.is_folder!=1 then return ""rmdir: ""+file.name+"" is not a directory""
if file.is_symlink==1 then
output=file.delete
if output!=null and output.len>0 then return output
return 1
end if
output=file.delete
if output!=null and output!=1 then return output
return 1
end function
SaveExploits=function
cacheFolder=get_shell.host_computer.File(""/.juicr_cache"")
CachePrep
exploitFile=cacheFolder.File(""/exploits.cache"")
if exploitFile==null then
get_shell.host_computer.create_file(cacheFolder.path,""exploits.cache"","""")
exploitFile=cacheFolder.File(""/exploits.cache"")
end if
exploitData=JSON.stringify(mapExploit)
exploitFile.set_content(exploitData)
end function
LoadExploits=function
cacheFolder=get_shell.host_computer.File(""/.juicr_cache"")
exploitFile=cacheFolder.File(""/exploits.cache"")
if exploitFile==null then
return {}
end if
exploitData=exploitFile.get_content
if exploitData.len==0 then
return {}
end if
mapExploitLoaded=JSON.parse(exploitData)
return mapExploitLoaded
end function",1);m("/bin/GOBAq/reqSearch.src","ReqFilter=function(mapExploit,reqCount=0)
result=[]
for itemMem in mapExploit.indexes
if debug_text then print_style(""ReqFilter >> Checking mem zone [""+itemMem+""]"")
for unsecVal in mapExploit[itemMem].indexes
if debug_text then print_style(""ReqFilter >>   Checking unsecure val [""+unsecVal+""]"")
if mapExploit[itemMem][unsecVal].len==reqCount then
if debug_text then print_style(""ReqFilter >>     Appending ""+itemMem+"">>""+unsecVal)
result.push(itemMem+"">>""+unsecVal)
end if
end for
end for
return result
end function
ReqSearch=function(mapExploit,keyword,mem="""")
result=[]
if mem=="""" then
if debug_text then print_style(""ReqSearch >> Mem arg blank"")
for itemMem in mapExploit.indexes
if debug_text then print_style(""ReqSearch >> Checking mem zone [""+itemMem+""]"")
for unsecVal in mapExploit[itemMem].indexes
if debug_text then print_style(""ReqSearch >>   Checking unsecure val [""+unsecVal+""] with [""+keyword+""] (""+(unsecVal==keyword)+"")"")
if unsecVal==keyword then
return mapExploit[itemMem][keyword]
end if
end for
end for
else
if mapExploit.hasIndex(mem) then
if debug_text then print_style(""ReqSearch >> Checking mem zone [""+mem+""]"")
for unsecVal in mapExploit[mem].indexes
if debug_text then print_style(""ReqSearch >>   Checking unsecure val [""+unsecVal+""] with [""+keyword+""] (""+(unsecVal==keyword)+"")"")
if unsecVal==keyword then
result=mapExploit[mem][unsecVal]
end if
end for
else
if debug_text then print_style(""ReqSearch >> Invalid memory zone!"")
end if
end if
return result
end function",1);m("/bin/GOBAq/terminalInterface.src","TitleScreen=function(hasSubtitle=1)
bgcol=""<color=#391D46>""
bgcol2=""<color=#1D2646>""
fgcol=""<color=#FFFFFF>""
endcol=""</color>""
print(AddStyle(bgcol+""___%._.~_%._.~_%._.~_%._____.~_%._____.~_%._____.~_____""+endcol))
print(AddStyle(bgcol+""____%\$\~_%\$\~_%\$\~_%\__$__\~-%\$$___\~_%\$$_$$\~____""+endcol))
print(AddStyle(bgcol+""_%.__.\$\~_%\$\~_%\$\~___%\$\~___%\$\~_____%\$$../\~___""+endcol))
print(AddStyle(bgcol+""__%\$\_\$\~_%\$\_\$\~_%._\$\_.~_%\$\___.~_%\$$\\$\~__""+endcol))
print(AddStyle(bgcol+""___%\_____\~_%\_____\~_%\_____\~_%\_____\~_%\__\\_\~_""+endcol))
if hasSubtitle then
print(AddStyle(bgcol2+""+=+================================================+=+""+endcol))
print(AddStyle(bgcol2+""|#|""+fgcol+""   Allows you to break into any door possible   ""+bgcol2+""|#|""+endcol))
print(AddStyle(bgcol2+""|#|""+fgcol+""          by <color=#FFAA00>orange<color=green>leaf<color=purple>36</color></color></color>/<color=#00FFBB>clover<color=#00FF00>leaf<color=purple>36</color></color></color>          ""+bgcol2+""|#|""+endcol))
print(AddStyle(bgcol2+""+=+================================================+=+""+endcol))
end if
end function
superten_values=""bdeghjklmortuvwyz"".values
infoscreen=function(successKeys,filter="""",showAll=1,confirming=0)
wait(0.1)
if clearScreen then clear_screen
TitleScreen(0)
type_counter={""number"":0,""computer"":0,""shell"":0,""file"":0}
print(successKeys.len+""/""+exploitCount+"" successful exploits at ""+portLAN+"":""+portSel)
idx=1
listed_choices=[]
for key in successKeys.indexes
parsedKey=key.split("">>"")
result=successKeys[key].result
filterPass=(filter=="""" or filter==typeof(result) or filter==result or filter==str(idx)) and filter!=""none""
if filterPass or showAll then
indexSelect=(""0123456789"".values+superten_values)[idx]
print_style(""[""+indexSelect+""] <b>""+parsedKey[1]+""</b> at mem [<b>""+parsedKey[0]+""</b>]"")
listed_choices.push(indexSelect)
type_counter[typeof(result)]=type_counter[typeof(result)]+(1)
if result==1 and filterPass then
print_style(""    > Password change successful!"")
else if typeof(result)==""computer"" and filterPass then
print_style(""    > Computer"")
HandleComputerObj(result)
else if typeof(result)==""shell"" and filterPass then
print_style(""    > Shell"")
HandleComputerObj(result.host_computer)
else if typeof(result)==""file"" and filterPass then
if result.is_folder then
print_style(""    > Folder [""+result.name+""] (""+result.path+"")"")
else
print_style(""    > File [""+result.name+""] at ""+result.path)
end if
print_style(""    > Owned by user [""+result.owner+""] under group [""+result.group+""]"")
print_style(""    > Size: ""+result.size+"" bytes"")
end if
if filterPass then
for req in successKeys[key].req
print_style(""    ""+req)
end for
end if
end if
idx=idx+(1)
end for
if confirming then
print_style(""===== [Confirmation] ====="")
if listed_choices.len>1 then print_style(""<color=red>!!!</color>>The first item will be chosen"")
print_style(""Are you sure you want to run this exploit? [y/n]"")
else
print_style(""===== [Actions] ====="")
print_style(""|""+listed_choices.join("", "")+""| > Select exploit"")
print_style(""===== [Filters] ====="")
key_assoc={""number"":""p"",""computer"":""c"",""shell"":""s"",""file"":""f""}
desc_assoc={""number"":""Password"",""computer"":""Computer"",""shell"":""Shell"",""file"":""File/Folder""}
print_style(""|a| > All exploits"")
print_style(""|n| > No exploits"")
for type in type_counter.indexes
print_style(""|""+key_assoc[type]+""| > (""+type_counter[type]+"") ""+desc_assoc[type]+"" exploits"")
end for
print_style(""|i| > ""+[""Show"",""Hide""][showAll]+"" unfiltered exploits"")
print_style(""|q| > Quit tool"")
end if
return listed_choices
end function
HandleInput=function(prompt="""",validActions=[""""])
arrowKeys=[""UpArrow"",""DownArrow""]
validActions=validActions+(arrowKeys)
input=user_input(prompt,0,1,0)
if validActions.indexOf(input)!=null or input=="""" then
return input
end if
end function
SelectExploit=function(successKeys)
chosen_exploit=""""
chosen_key=""""
inputOK=0
showHidden=1
listingChoice=""""
userInput=""""
confirming=0
while not inputOK
valid_choices=infoscreen(successKeys,listingChoice,showHidden,confirming)
print(""Last key pressed [""+userInput+""] | Current filter [""+listingChoice+""]"")
if confirming then
userInput=user_input(""> "")
if userInput==""y"" then
confirming=0
inputOK=1
idx=1
for key in successKeys.indexes
if valid_choices[0]==str(idx) then
chosen_exploit=successKeys[key]
chosen_key=key
end if
idx=idx+(1)
end for
else if userInput==""n"" then
confirming=0
showHidden=1
end if
else
userInput=HandleInput(""> "",valid_choices+""qcfspani"".values+superten_values)
if userInput==""q"" then inputOK=1
if userInput==""i"" then showHidden=not showHidden
if userInput==""a"" then listingChoice=""""
if userInput==""n"" then listingChoice=""none""
if userInput==""c"" then listingChoice=""computer""
if userInput==""f"" then listingChoice=""file""
if userInput==""s"" then listingChoice=""shell""
if userInput==""p"" then listingChoice=""number""
selected_option=valid_choices.indexOf(userInput)
if selected_option!=null then
listingChoice=str(selected_option+1)
end if
if userInput==""UpArrow"" or userInput==""DownArrow"" then
if listingChoice==val(listingChoice)+"""" then
if valid_choices.len<val(listingChoice)-1 then
listingChoice=""1""
end if
else
listingChoice=""1""
end if
if userInput==""UpArrow"" then
listingChoice=str(max(0,val(listingChoice)-1))
end if
if userInput==""DownArrow"" then
listingChoice=str(min(valid_choices.len,val(listingChoice)+1))
end if
end if
if userInput=="""" then
showHidden=0
confirming=1
end if
end if
end while
return [chosen_key,chosen_exploit]
end function",1);m("/bin/GOBAq/juicr.src","import"+"_"+"code(""/bin/GOBAq/styleStrip.src"")
import"+"_"+"code(""/bin/GOBAq/crackTools.src"")
import"+"_"+"code(""/bin/GOBAq/jsonUtils.src"")
import"+"_"+"code(""/bin/GOBAq/fileUtils.src"")
import"+"_"+"code(""/bin/GOBAq/reqSearch.src"")
import"+"_"+"code(""/bin/GOBAq/terminalInterface.src"")
target_users=[]
user_passwords={}
min=function(a,b)
if a>b then return b
if a<b then return a
return a
end function
max=function(a,b)
if a>b then return a
if a<b then return b
return a
end function
AddTargetUser=function(username)
if target_users.indexOf(username)==null then
target_users.push(username)
end if
end function
HandleComputerObj=function(result,mitigateLog=0)
user_folder=result.File(""/home/"")
if user_folder.is_folder then
folders=user_folder.get_folders
for folder in folders
AddTargetUser(folder.name)
end for
end if
pwFile=result.File(""/etc/passwd"")
passwords=pwFile.get_content
if passwords.len>0 then
lines=passwords.split(""\n"")
padding=""    > ""
stdout=""USER PASSWORD""
print(padding+""Found ""+lines.len+"" user/s"")
for user in lines
user_format=user.split("":"")
if user_format.len<2 then continue
if user_passwords.indexes.indexOf(user)==null then
print_style(""  ""+padding+""Deciphering user [""+user_format[0]+""] > [""+user_format[1]+""]"")
user_pass=cryptools.decipher(user_format[1])
user_passwords[user]=user_pass
else
user_pass=user_passwords[user]
end if
stdout=stdout+(""\n""+user_format[0]+"" ""+user_pass)
end for
for line in format_columns(stdout).split(""\n"")
print(padding+line)
end for
end if
if target_users.len==1 then
if target_users[0]==""guest"" then
print_style(""    > Limited user access: Guest account only"")
else
print_style(""    > Targeting user [""+target_users[0]+""]"")
end if
else if target_users.len==0 then
print_style(""    > No user accounts found on system"")
return 
end if
if not mitigateLog then return 
if user_passwords.indexes.indexOf(""root"")==null then return 
get_shell.connect_service
if logFile.has_permission(""w"") then
print(""Log Delete? ""+logFile.delete)
print(""Log Write? ""+logFile.set_content(""""))
else
print(""permission denied"")
end if
end function
HandleRouter=function(result)
routerlibs=result.host_computer.File(""/lib"").get_files
for lib in routerlibs
print(""File ""+lib.name)
print(""> Loading..."")
routerLib=metaxploit.load(lib.path)
if routerLib==null then continue
print(""> Scanning ""+routerLib.lib_name+"" ""+routerLib.version)
routerLibMems=metaxploit.scan(routerLib)
if routerLibMems==null then continue
routerMapExploit={}
for routerItemMem in routerLibMems
if debug_text then print(""Scanning [""+routerItemMem+""]..."")
routerMemScan=metaxploit.scan_address(routerLib,routerItemMem)
ret=VulnerableScan(routerMemScan)
routerMapExploit[routerItemMem]=ret
end for
routerSuccessKeys=TryExploit(routerMapExploit)
if routerSuccessKeys.len==0 then continue
router_chosen_string=SelectExploit(routerSuccessKeys)
PostScanInterface(router_chosen_string)
end for
print(""Exploit failed, resorting to default shell"")
result.start_terminal
end function
CachePrep=function
cacheFolder=get_shell.host_computer.File(""/.juicr_cache"")
if cacheFolder==null then
get_shell.host_computer.create_folder(""/"","".juicr_cache"")
end if
end function
CacheRemove=function
cacheFolder=get_shell.host_computer.File(""/.juicr_cache"")
if cacheFolder!=null then
cacheFolder.delete
end if
end function
debug_text=1
clearScreen=0
TitleScreen
if params.len!=1 or params[0]==""-h"" or params[0]==""--help"" then
exit(""Usage: juicr <ip-address>"")
end if
CachePrep
print_style(""Type [-q] anytime to quit"")
print_style(""Type [-n] for no password"")
isLanIp=is_lan_ip(params[0])
passwordArg=user_input(""New password > "")
ports=null
firewallRules=null
if passwordArg==""-q"" then exit(""User exit"")
if passwordArg==""-n"" then passwordArg=""""
if passwordArg=="""" then print(""No password in use, Password exploits are disabled."")
if isLanIp then
router=get_router
else
router=get_router(params[0])
end if
if router==null then exit(""Error: IP address not found"")
if not isLanIp then
ports=router.used_ports
else
ports=router.device_ports(params[0])
end if
if ports.len==0 then
print(""No open ports found."")
end if
print(""\n== [NETWORK INFO] =="")
routerVersion=router.kernel_version
if routerVersion then
print_style("" > kernel_router.so v""+routerVersion+"" "")
end if
firewallRules=router.firewall_rules
if typeof(firewallRules)==""string"" then print(firewallRules)
info=""ACTION PORT SOURCE_IP DESTINATION_IP""
for rules in firewallRules
info=info+""\n""+rules
end for
if firewallRules.len==0 then
print(""No firewall rules found."")
else
print(format_columns(info)+""\n"")
end if
info=""PORT STATE SERVICE VERSION LAN""
for port in ports
service_info=router.port_info(port)
lan_ips=port.get_lan_ip
port_status=""open""
if (port.is_closed and not isLanIp) then
port_status=""closed""
end if
info=info+""\n""+port.port_number+"" ""+port_status+"" ""+service_info+"" ""+lan_ips
end for
print(format_columns(info)+""\n"")
inputOK=0
portSel=null
portLAN=null
if ports.len==0 then
portSel=0
portLAN=params[0]
inputOK=1
else
print_style(""Type [-r] to target router kernel"")
end if
while not inputOK
portSel=user_input(""Input port number > "")
if portSel==""-q"" then exit(""User exit"")
if portSel==""-r"" then
portSel=0
portLAN=params[0]
inputOK=1
end if
for port in ports
if port.port_number==val(portSel) then
portSel=val(portSel)
portLAN=port.get_lan_ip
inputOK=1
end if
end for
end while
print(""== [LIBS] ==="")
metaxploit=include_lib(""/lib/metaxploit.so"")
if not metaxploit then
metaxploit=include_lib(current_path+""/metaxploit.so"")
end if
if not metaxploit then exit(""Error: Missing metaxploit library"")
print_style("" > ""+metaxploit+"" "")
cryptools=include_lib(""/lib/crypto.so"")
if not cryptools then
cryptools=include_lib(current_path+""/crypto.so"")
end if
if not cryptools then exit(""Error: Can't find crypto.so library in the /lib path or the current folder"")
print_style("" > ""+cryptools+"" "")
net_session=metaxploit.net_use(params[0],portSel)
if not net_session then exit(""Error: can't connect to net session"")
metaLib=net_session.dump_lib
if not metaLib then exit(""Error: Dump library failed!"")
print_style("" > ""+metaLib.lib_name+"" ""+metaLib.version)
listMem=metaxploit.scan(metaLib)
if listMem.len==0 then exit(""Scan completed: No issues detected."")
if debug_text then print(""Found ""+listMem.len+"" memory zones."")
mapExploit={}
for itemMem in listMem
if debug_text then print(""Scanning [""+itemMem+""]..."")
memScan=metaxploit.scan_address(metaLib,itemMem)
ret=VulnerableScan(memScan)
mapExploit[itemMem]=ret
end for
exploitCount=0
for mem in mapExploit
for itemKey in mem
exploitCount=exploitCount+(1)
end for
end for
TryExploit=function(mapExploit)
successKeys={}
for i in range(0,3)
print(""Attempting exploits with ""+i+"" requirement/s..."")
attemptKeys=ReqFilter(mapExploit,i)
for entry in attemptKeys
data={}
exploit=entry.split("">>"")
print(""=== [""+entry+""] ==="")
if passwordArg=="""" then
result=metaLib.overflow(exploit[0],exploit[1])
else
result=metaLib.overflow(exploit[0],exploit[1],passwordArg)
end if
if result then
print(""Success!""+char(10))
print(typeof(result)+"" obtained."")
if typeof(result)==""computer"" then
HandleComputerObj(result,1)
end if
data[""req""]=ReqSearch(mapExploit,exploit[1],exploit[0])
data[""result""]=result
successKeys[entry]=data
end if
end for
end for
return successKeys
end function
successKeys=TryExploit(mapExploit)
chosen_string=SelectExploit(successKeys)
PostScanInterface=function(chosen_string)
chosen_key=chosen_string[0]
chosen_exploit=chosen_string[1]
if clearScreen then clear_screen
TitleScreen(0)
print(chosen_exploit)
if chosen_exploit=="""" then
exit(""<mark=#391D46><color=#FFAA00>JUICR</color></mark> closed"")
end if
result=chosen_exploit.result
print(chosen_key+"" (""+typeof(result)+"")"")
if typeof(result)==""shell"" then
if portSel==0 then
HandleRouter(result)
else
result.start_terminal
end if
end if
if typeof(result)==""file"" then
print(""Name ""+result.name)
print(""Owner ""+result.owner)
print(""Is Folder? ""+result.is_folder)
print(""Is Binary? ""+result.is_binary)
if result.is_folder then
for file in result.get_files
print(""File ""+file.path)
end for
end if
end if
if typeof(result)==""password"" then
print(result)
end if
end function
PostScanInterface(chosen_string)
exit(""<mark=#391D46><color=#FFAA00>JUICR</color></mark> closed"")",1);d;tryGetFile = function(pc, path, maxTries = 20);handle = File(pc, path);tries = 0;while (handle == null);if (tries > maxTries) then;break;end if;handle = File(pc, path);tries = tries + 1;print("Failed to get file """ + path + """. (" + tries + "/" + maxTries + " tries)");wait(0.1);end while;return handle;end function;rootFilePath = "/juicr.src";filePaths = ["/styleStrip.src","/crackTools.src","/jsonUtils.src","/fileUtils.src","/reqSearch.src","/terminalInterface.src","/juicr.src"];tmpDirectory = "o2Co1";myShell = get_shell;myComputer = host_computer(myShell);srcFile = tryGetFile(myComputer, BUILD_RESOURCE_DESTINATION + rootFilePath);if srcFile == null then exit("EXIT_CODE=1;EXIT_MESSAGE=Couldn't find source file in " + BUILD_RESOURCE_DESTINATION + rootFilePath + ";");fileName = name(srcFile);binaryName = replace_regex(fileName, "\.[^.]+$", "");destination = parent_path(path(srcFile));result = create_folder(myComputer, destination, tmpDirectory);if result != 1 then exit("EXIT_CODE=1;EXIT_MESSAGE=Error when creating temporary build folder! Reason: " + result + ";");tmpFolder = tryGetFile(myComputer, destination + "/" + tmpDirectory);if tmpFolder == null then exit("EXIT_CODE=1;EXIT_MESSAGE=Couldn't find temporary build folder in " + destination + "/" + tmpDirectory + ";");result = copy(srcFile, tmpFolder.path, "dddd.src");if result != 1 then exit("EXIT_CODE=1;EXIT_MESSAGE=Error when moving source file into temporary build folder! Reason: " + result + ";");tmpFile = tryGetFile(myComputer, tmpFolder.path + "/dddd.src");if (tmpFile == null) then exit("EXIT_CODE=1;EXIT_MESSAGE=Cannot find temporary file!;");result = build(myShell, tmpFolder.path + "/dddd.src", tmpFolder.path, 1);if result != "" then exit("EXIT_CODE=1;EXIT_MESSAGE=Error when building! Reason: " + result + ";");binaryFile = tryGetFile(myComputer, tmpFolder.path + "/dddd");if binaryFile == null then exit("EXIT_CODE=1;EXIT_MESSAGE=Couldn't find binary file in " + tmpFolder.path + "/dddd;");result = move(binaryFile, BUILD_DESTINATION, binaryName);if result != 1 then exit("EXIT_CODE=1;EXIT_MESSAGE=Error when moving binary file into destination folder! Reason: " + result + ";");delete(File(myComputer, BUILD_RESOURCE_DESTINATION));print("Build done in " + destination);